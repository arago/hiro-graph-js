# Tasks in Detail

This gets it's own page as it will be used a lot. 

> *Tasks* are async actions with a unique identifier. Only one task with the given identifier should be inflight at one time.

## Task State.

Tasks have the following properties.

 - `loading`: this is whether the task is in progress. It is kinda implicit but somewhat complex to imply, so we have a property.
 - `start`: hammertime that the task (last) started (if it has started)
 - `finish`: hammertime that the task (last) finished (if it has finished)
 - `result`: the last result of the task
 - `error`: the last error (cleared on a successful result)

This is complex and unwieldy to manage so we have `whenTask` you can use. It's usage is like this.

```javascript
import { whenTask } from "hiro-graph-redux";

//assume we have a task
const task;

const value = whenTask(task, {
    pre: () => "the task has not started yet. it doesn't exist"
    loading: () => "the task is loading",
    reloading: () => "the task is loading, but we have a result/error"
    ok: results => "the task has finished successfully, results: " + JSON.stringify(results),
    error: err => "the task errored: " + err.message,
});

//depending on the state of the task, only one function will be executed.
```

All the keys to the second argument of `whenTask` default to a no-op, except `reloading` which defaults to the value of `loading`. i.e. if you don't want to handle `reloading` any different to `loading` you can omit it.

## Creating Tasks

Tasks are created with the `createTask` function. The signature of this function is

```javascript
const createTask = (handlerFn, ?key) => ({ 
    action: actionCreator, 
    selector: taskSelector,
    key: givenKeyOrAutoGeneratedOne
});
```

So first you pass in a handlerFn, which is exactly the same as the `createAction` uses (see [`createAction`](./action-creators.md#createaction)) and optionally a `key`.

> If you wish to seperate these functions to give the same task different keys, `createTaskFactory` just takes the `handler` and returns a function of `key`. Basic currying.

The `key` must be either a `string` or a `function`. If a string, then the key is static every dispatch of the task will use the same key and no two would go in parallel.

This is not always desired, as your task can accept arguments and you may want to give it specific keys based on the args. For example the call to fetch a page of data will be mostly the same for each page, except the page number. And it seems valid to fetch multiple pages in parallel if we want.

```javascript
const fetchPageFactory = createTaskFactory(({ orm }, page) => {
    const limit = 10,
    const offset = (page - 1) * limit;
    return orm.Things.find({}, { limit, offset })
        // NB we return the Vertex objects
        // But the selector returns plain data objects
}

const fetchOnePageAtATime = fetchPage("fixed-key");
const fetchPagesInParallel = fetchPage(page => "fetching-" + page);

store.dispatch(fetchOnePageAtATime(1)); //fetch page one
store.dispatch(fetchOnePageAtATime(2)); // does nothing, page one still loading

store.dispatch(fetchPagesInParallel(1)); //fetch page one
store.dispatch(fetchPagesInParallel(2)); //fetch page two
```

> Remember that these keys are **application global**. So make sure they are privately namespaced if you are in a library.

## Task Results and Vertex handling

Any vertex updated/deleted or creating during a task is added to a cache. The `taskSelector` (and results from `createVertexSelector`) always pull from this cache and will show new results if any values change. 

This means it is efficient to `connect` with a `mapStateToProps` function using these selectors as your data will be consistent across the application.

i.e

```javascript
//
// THIS IS DISCOURAGED
//
createTask(orm => {
    return orm.Thing.find({})
        .then(nodes => nodes.map(n => ({
            "foo": n.get("foo")
        }))) // we lost the reference to the vertex data by extracting it
}

//
//  In favour of
//
createTask(orm => {
    return orm.Thing.find({})
    // just return the array of vertices
}
```

Because, in the first case, if another dispatch triggered an update the the `foo` value of one of these vertices then your task would not know and any components using the data would not update.

In the second case, after a change to a `foo` field in one of the vertices, the taskSelector would update and a new result set would appear and you app stays consistent. There are some more complex interactions at play concerning consistency, see [tasks and consistency](./tasks-and-consistency.md)

## Cancelling tasks.

Tasks are also cancellable. You may have a component that wishes to start a task, but cancelling any existing tasks first. The action to cancel a task can be created with `cancelTask` and the key.


```javascript
import { createAction, createTask, cancelTask } from "hiro-graph-redux";

const theTask = createTask(({ orm }) => {
    return orm...
}, "cancel-me-task");

const myCancelThenRunTask = createAction({ dispatch } => {
    dispatch(cancelTask("cancel-me-task"));
    dispatch(theTask());
});

store.dispatch(myCancelThenRunTask());
```

You could also cancel running tasks with the return value of dispatch.

```javascript 

const promise = store.dispatch(someTask());
promise.cancel("I just wanted to stop the task"); //cancels the task.

const task = getTaskState(store.getState());

// task.error === new Error("I just wanted to stop the task");
```

| Cancelling the promise does *NOT* stop the handler from being call or any other side-effects in the handler from happening. Only that this *task* will be considered cancelled and be in an error state. |
| --- |

> We have yet to so how useful this feature will be, but hopefully together the feature of the tasks should provide enough flexibility to do anything we need.

- back to: [table of contents](./README.md)
